{"ast":null,"code":"import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nexport var REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n  REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n  REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n  /**\n   * listen to Postgres changes.\n   */\n  REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nexport var REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n  REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n  REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n  REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n  REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nexport default class RealtimeChannel {\n  constructor( /** Topic name can be any string. */\n  topic) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      config: {}\n    };\n    let socket = arguments.length > 2 ? arguments[2] : undefined;\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = {};\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.subTopic = topic.replace(/^realtime:/i, '');\n    this.params.config = Object.assign({\n      broadcast: {\n        ack: false,\n        self: false\n      },\n      presence: {\n        key: ''\n      }\n    }, params.config);\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this._onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log('channel', \"close \".concat(this.topic, \" \").concat(this._joinRef()));\n      this.state = CHANNEL_STATES.closed;\n      this.socket._remove(this);\n    });\n    this._onError(reason => {\n      if (this._isLeaving() || this._isClosed()) {\n        return;\n      }\n      this.socket.log('channel', \"error \".concat(this.topic), reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return;\n      }\n      this.socket.log('channel', \"timeout \".concat(this.topic), this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n      this._trigger(this._replyEventName(ref), payload);\n    });\n    this.presence = new RealtimePresence(this);\n    this.broadcastEndpointURL = this._broadcastEndpointURL();\n  }\n  /** Subscribe registers your client with the server */\n  subscribe(callback) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.timeout;\n    var _a, _b;\n    if (!this.socket.isConnected()) {\n      this.socket.connect();\n    }\n    if (this.joinedOnce) {\n      throw \"tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance\";\n    } else {\n      const {\n        config: {\n          broadcast,\n          presence\n        }\n      } = this.params;\n      this._onError(e => callback && callback('CHANNEL_ERROR', e));\n      this._onClose(() => callback && callback('CLOSED'));\n      const accessTokenPayload = {};\n      const config = {\n        broadcast,\n        presence,\n        postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(r => r.filter)) !== null && _b !== void 0 ? _b : []\n      };\n      if (this.socket.accessToken) {\n        accessTokenPayload.access_token = this.socket.accessToken;\n      }\n      this.updateJoinPayload(Object.assign({\n        config\n      }, accessTokenPayload));\n      this.joinedOnce = true;\n      this._rejoin(timeout);\n      this.joinPush.receive('ok', _ref2 => {\n        let {\n          postgres_changes: serverPostgresFilters\n        } = _ref2;\n        var _a;\n        this.socket.accessToken && this.socket.setAuth(this.socket.accessToken);\n        if (serverPostgresFilters === undefined) {\n          callback && callback('SUBSCRIBED');\n          return;\n        } else {\n          const clientPostgresBindings = this.bindings.postgres_changes;\n          const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n          const newPostgresBindings = [];\n          for (let i = 0; i < bindingsLen; i++) {\n            const clientPostgresBinding = clientPostgresBindings[i];\n            const {\n              filter: {\n                event,\n                schema,\n                table,\n                filter\n              }\n            } = clientPostgresBinding;\n            const serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];\n            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {\n              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                id: serverPostgresFilter.id\n              }));\n            } else {\n              this.unsubscribe();\n              callback && callback('CHANNEL_ERROR', new Error('mismatch between server and client bindings for postgres changes'));\n              return;\n            }\n          }\n          this.bindings.postgres_changes = newPostgresBindings;\n          callback && callback('SUBSCRIBED');\n          return;\n        }\n      }).receive('error', error => {\n        callback && callback('CHANNEL_ERROR', new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n        return;\n      }).receive('timeout', () => {\n        callback && callback('TIMED_OUT');\n        return;\n      });\n    }\n    return this;\n  }\n  presenceState() {\n    return this.presence.state;\n  }\n  async track(payload) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return await this.send({\n      type: 'presence',\n      event: 'track',\n      payload\n    }, opts.timeout || this.timeout);\n  }\n  async untrack() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return await this.send({\n      type: 'presence',\n      event: 'untrack'\n    }, opts);\n  }\n  on(type, filter, callback) {\n    return this._on(type, filter, callback);\n  }\n  /**\n   * Sends a message into the channel.\n   *\n   * @param args Arguments to send to channel\n   * @param args.type The type of event to send\n   * @param args.event The name of the event being sent\n   * @param args.payload Payload to be sent\n   * @param opts Options to be used during the send process\n   */\n  async send(args) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a, _b;\n    if (!this._canPush() && args.type === 'broadcast') {\n      const {\n        event,\n        payload: endpoint_payload\n      } = args;\n      const options = {\n        method: 'POST',\n        headers: {\n          apikey: (_a = this.socket.apiKey) !== null && _a !== void 0 ? _a : '',\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          messages: [{\n            topic: this.subTopic,\n            event,\n            payload: endpoint_payload\n          }]\n        })\n      };\n      try {\n        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_b = opts.timeout) !== null && _b !== void 0 ? _b : this.timeout);\n        if (response.ok) {\n          return 'ok';\n        } else {\n          return 'error';\n        }\n      } catch (error) {\n        if (error.name === 'AbortError') {\n          return 'timed out';\n        } else {\n          return 'error';\n        }\n      }\n    } else {\n      return new Promise(resolve => {\n        var _a, _b, _c;\n        const push = this._push(args.type, args, opts.timeout || this.timeout);\n        if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n          resolve('ok');\n        }\n        push.receive('ok', () => resolve('ok'));\n        push.receive('timeout', () => resolve('timed out'));\n      });\n    }\n  }\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n    this.state = CHANNEL_STATES.leaving;\n    const onClose = () => {\n      this.socket.log('channel', \"leave \".concat(this.topic));\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n    };\n    this.rejoinTimer.reset();\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy();\n    return new Promise(resolve => {\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive('ok', () => {\n        onClose();\n        resolve('ok');\n      }).receive('timeout', () => {\n        onClose();\n        resolve('timed out');\n      }).receive('error', () => {\n        resolve('error');\n      });\n      leavePush.send();\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {});\n      }\n    });\n  }\n  /** @internal */\n  _broadcastEndpointURL() {\n    let url = this.socket.endPoint;\n    url = url.replace(/^ws/i, 'http');\n    url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '');\n    return url.replace(/\\/+$/, '') + '/api/broadcast';\n  }\n  async _fetchWithTimeout(url, options, timeout) {\n    const controller = new AbortController();\n    const id = setTimeout(() => controller.abort(), timeout);\n    const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {\n      signal: controller.signal\n    }));\n    clearTimeout(id);\n    return response;\n  }\n  /** @internal */\n  _push(event, payload) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n    if (!this.joinedOnce) {\n      throw \"tried to push '\".concat(event, \"' to '\").concat(this.topic, \"' before joining. Use channel.subscribe() before pushing events\");\n    }\n    let pushEvent = new Push(this, event, payload, timeout);\n    if (this._canPush()) {\n      pushEvent.send();\n    } else {\n      pushEvent.startTimeout();\n      this.pushBuffer.push(pushEvent);\n    }\n    return pushEvent;\n  }\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   *\n   * @internal\n   */\n  _onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  /** @internal */\n  _isMember(topic) {\n    return this.topic === topic;\n  }\n  /** @internal */\n  _joinRef() {\n    return this.joinPush.ref;\n  }\n  /** @internal */\n  _trigger(type, payload, ref) {\n    var _a, _b;\n    const typeLower = type.toLocaleLowerCase();\n    const {\n      close,\n      error,\n      leave,\n      join\n    } = CHANNEL_EVENTS;\n    const events = [close, error, leave, join];\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return;\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref);\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n    }\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(bind => {\n        var _a, _b, _c;\n        return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n      }).map(bind => bind.callback(handledPayload, ref));\n    } else {\n      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(bind => {\n        var _a, _b, _c, _d, _e, _f;\n        if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n          if ('id' in bind) {\n            const bindId = bind.id;\n            const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n            return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n          } else {\n            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n            return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n          }\n        } else {\n          return bind.type.toLocaleLowerCase() === typeLower;\n        }\n      }).map(bind => {\n        if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n          const postgresChanges = handledPayload.data;\n          const {\n            schema,\n            table,\n            commit_timestamp,\n            type,\n            errors\n          } = postgresChanges;\n          const enrichedPayload = {\n            schema: schema,\n            table: table,\n            commit_timestamp: commit_timestamp,\n            eventType: type,\n            new: {},\n            old: {},\n            errors: errors\n          };\n          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n        }\n        bind.callback(handledPayload, ref);\n      });\n    }\n  }\n  /** @internal */\n  _isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  /** @internal */\n  _isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  /** @internal */\n  _isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  /** @internal */\n  _isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n  /** @internal */\n  _replyEventName(ref) {\n    return \"chan_reply_\".concat(ref);\n  }\n  /** @internal */\n  _on(type, filter, callback) {\n    const typeLower = type.toLocaleLowerCase();\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback\n    };\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding);\n    } else {\n      this.bindings[typeLower] = [binding];\n    }\n    return this;\n  }\n  /** @internal */\n  _off(type, filter) {\n    const typeLower = type.toLocaleLowerCase();\n    this.bindings[typeLower] = this.bindings[typeLower].filter(bind => {\n      var _a;\n      return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n    });\n    return this;\n  }\n  /** @internal */\n  static isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false;\n    }\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /** @internal */\n  _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n    if (this.socket.isConnected()) {\n      this._rejoin();\n    }\n  }\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   *\n   * @internal\n   */\n  _onClose(callback) {\n    this._on(CHANNEL_EVENTS.close, {}, callback);\n  }\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   *\n   * @internal\n   */\n  _onError(callback) {\n    this._on(CHANNEL_EVENTS.error, {}, reason => callback(reason));\n  }\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   *\n   * @internal\n   */\n  _canPush() {\n    return this.socket.isConnected() && this._isJoined();\n  }\n  /** @internal */\n  _rejoin() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n    if (this._isLeaving()) {\n      return;\n    }\n    this.socket._leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  /** @internal */\n  _getPayloadRecords(payload) {\n    const records = {\n      new: {},\n      old: {}\n    };\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(payload.columns, payload.record);\n    }\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n    }\n    return records;\n  }\n}","map":{"version":3,"names":["CHANNEL_EVENTS","CHANNEL_STATES","Push","Timer","RealtimePresence","Transformers","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","REALTIME_LISTEN_TYPES","REALTIME_SUBSCRIBE_STATES","REALTIME_CHANNEL_STATES","RealtimeChannel","constructor","topic","params","arguments","length","undefined","config","socket","bindings","state","closed","joinedOnce","pushBuffer","subTopic","replace","Object","assign","broadcast","ack","self","presence","key","timeout","joinPush","join","rejoinTimer","_rejoinUntilConnected","reconnectAfterMs","receive","joined","reset","forEach","pushEvent","send","_onClose","log","concat","_joinRef","_remove","_onError","reason","_isLeaving","_isClosed","errored","scheduleTimeout","_isJoining","_on","reply","payload","ref","_trigger","_replyEventName","broadcastEndpointURL","_broadcastEndpointURL","subscribe","callback","isConnected","connect","e","accessTokenPayload","postgres_changes","_b","_a","map","r","filter","accessToken","access_token","updateJoinPayload","_rejoin","_ref2","serverPostgresFilters","setAuth","clientPostgresBindings","bindingsLen","newPostgresBindings","i","clientPostgresBinding","event","schema","table","serverPostgresFilter","push","id","unsubscribe","Error","error","JSON","stringify","values","presenceState","track","opts","type","untrack","on","args","_canPush","endpoint_payload","options","method","headers","apikey","apiKey","body","messages","response","_fetchWithTimeout","ok","name","Promise","resolve","_push","_c","updatePayload","leaving","onClose","close","destroy","leavePush","leave","trigger","url","endPoint","controller","AbortController","setTimeout","abort","fetch","signal","clearTimeout","startTimeout","_onMessage","_event","_ref","_isMember","typeLower","toLocaleLowerCase","events","indexOf","handledPayload","includes","bind","bindId","bindEvent","ids","data","_e","_d","_f","postgresChanges","commit_timestamp","errors","enrichedPayload","eventType","new","old","_getPayloadRecords","_isJoined","joining","binding","_off","isEqual","obj1","obj2","keys","k","_leaveOpenTopic","resend","records","convertChangeData","columns","record","old_record"],"sources":["/Users/geuse/Desktop/today-i-learned/node_modules/@supabase/realtime-js/src/RealtimeChannel.ts"],"sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\nimport Push from './lib/push'\nimport type RealtimeClient from './RealtimeClient'\nimport Timer from './lib/timer'\nimport RealtimePresence, {\n  REALTIME_PRESENCE_LISTEN_EVENTS,\n} from './RealtimePresence'\nimport type {\n  RealtimePresenceJoinPayload,\n  RealtimePresenceLeavePayload,\n  RealtimePresenceState,\n} from './RealtimePresence'\nimport * as Transformers from './lib/transformers'\n\nexport type RealtimeChannelOptions = {\n  config: {\n    /**\n     * self option enables client to receive message it broadcast\n     * ack option instructs server to acknowledge that broadcast message was received\n     */\n    broadcast?: { self?: boolean; ack?: boolean }\n    /**\n     * key option is used to track presence payload across clients\n     */\n    presence?: { key?: string }\n  }\n}\n\ntype RealtimePostgresChangesPayloadBase = {\n  schema: string\n  table: string\n  commit_timestamp: string\n  errors: string[]\n}\n\nexport type RealtimePostgresInsertPayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`\n    new: T\n    old: {}\n  }\n\nexport type RealtimePostgresUpdatePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`\n    new: T\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresDeletePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`\n    new: {}\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresChangesPayload<T extends { [key: string]: any }> =\n  | RealtimePostgresInsertPayload<T>\n  | RealtimePostgresUpdatePayload<T>\n  | RealtimePostgresDeletePayload<T>\n\nexport type RealtimePostgresChangesFilter<\n  T extends `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT}`\n> = {\n  /**\n   * The type of database change to listen to.\n   */\n  event: T\n  /**\n   * The database schema to listen to.\n   */\n  schema: string\n  /**\n   * The database table to listen to.\n   */\n  table?: string\n  /**\n   * Receive database changes when filter is matched.\n   */\n  filter?: string\n}\n\nexport type RealtimeChannelSendResponse = 'ok' | 'timed out' | 'error'\n\nexport enum REALTIME_POSTGRES_CHANGES_LISTEN_EVENT {\n  ALL = '*',\n  INSERT = 'INSERT',\n  UPDATE = 'UPDATE',\n  DELETE = 'DELETE',\n}\n\nexport enum REALTIME_LISTEN_TYPES {\n  BROADCAST = 'broadcast',\n  PRESENCE = 'presence',\n  /**\n   * listen to Postgres changes.\n   */\n  POSTGRES_CHANGES = 'postgres_changes',\n}\n\nexport enum REALTIME_SUBSCRIBE_STATES {\n  SUBSCRIBED = 'SUBSCRIBED',\n  TIMED_OUT = 'TIMED_OUT',\n  CLOSED = 'CLOSED',\n  CHANNEL_ERROR = 'CHANNEL_ERROR',\n}\n\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES\n\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nexport default class RealtimeChannel {\n  bindings: {\n    [key: string]: {\n      type: string\n      filter: { [key: string]: any }\n      callback: Function\n      id?: string\n    }[]\n  } = {}\n  timeout: number\n  state = CHANNEL_STATES.closed\n  joinedOnce = false\n  joinPush: Push\n  rejoinTimer: Timer\n  pushBuffer: Push[] = []\n  presence: RealtimePresence\n  broadcastEndpointURL: string\n  subTopic: string\n\n  constructor(\n    /** Topic name can be any string. */\n    public topic: string,\n    public params: RealtimeChannelOptions = { config: {} },\n    public socket: RealtimeClient\n  ) {\n    this.subTopic = topic.replace(/^realtime:/i, '')\n\n    this.params.config = {\n      ...{\n        broadcast: { ack: false, self: false },\n        presence: { key: '' },\n      },\n      ...params.config,\n    }\n    this.timeout = this.socket.timeout\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout\n    )\n    this.rejoinTimer = new Timer(\n      () => this._rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this._onClose(() => {\n      this.rejoinTimer.reset()\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket._remove(this)\n    })\n    this._onError((reason: string) => {\n      if (this._isLeaving() || this._isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this._on(CHANNEL_EVENTS.reply, {}, (payload: any, ref: string) => {\n      this._trigger(this._replyEventName(ref), payload)\n    })\n\n    this.presence = new RealtimePresence(this)\n\n    this.broadcastEndpointURL = this._broadcastEndpointURL()\n  }\n\n  /** Subscribe registers your client with the server */\n  subscribe(\n    callback?: (status: `${REALTIME_SUBSCRIBE_STATES}`, err?: Error) => void,\n    timeout = this.timeout\n  ): RealtimeChannel {\n    if (!this.socket.isConnected()) {\n      this.socket.connect()\n    }\n\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\n    } else {\n      const {\n        config: { broadcast, presence },\n      } = this.params\n      this._onError((e: Error) => callback && callback('CHANNEL_ERROR', e))\n      this._onClose(() => callback && callback('CLOSED'))\n\n      const accessTokenPayload: { access_token?: string } = {}\n      const config = {\n        broadcast,\n        presence,\n        postgres_changes:\n          this.bindings.postgres_changes?.map((r) => r.filter) ?? [],\n      }\n\n      if (this.socket.accessToken) {\n        accessTokenPayload.access_token = this.socket.accessToken\n      }\n\n      this.updateJoinPayload({ ...{ config }, ...accessTokenPayload })\n\n      this.joinedOnce = true\n      this._rejoin(timeout)\n\n      this.joinPush\n        .receive(\n          'ok',\n          ({\n            postgres_changes: serverPostgresFilters,\n          }: {\n            postgres_changes: {\n              id: string\n              event: string\n              schema?: string\n              table?: string\n              filter?: string\n            }[]\n          }) => {\n            this.socket.accessToken &&\n              this.socket.setAuth(this.socket.accessToken)\n\n            if (serverPostgresFilters === undefined) {\n              callback && callback('SUBSCRIBED')\n              return\n            } else {\n              const clientPostgresBindings = this.bindings.postgres_changes\n              const bindingsLen = clientPostgresBindings?.length ?? 0\n              const newPostgresBindings = []\n\n              for (let i = 0; i < bindingsLen; i++) {\n                const clientPostgresBinding = clientPostgresBindings[i]\n                const {\n                  filter: { event, schema, table, filter },\n                } = clientPostgresBinding\n                const serverPostgresFilter =\n                  serverPostgresFilters && serverPostgresFilters[i]\n\n                if (\n                  serverPostgresFilter &&\n                  serverPostgresFilter.event === event &&\n                  serverPostgresFilter.schema === schema &&\n                  serverPostgresFilter.table === table &&\n                  serverPostgresFilter.filter === filter\n                ) {\n                  newPostgresBindings.push({\n                    ...clientPostgresBinding,\n                    id: serverPostgresFilter.id,\n                  })\n                } else {\n                  this.unsubscribe()\n                  callback &&\n                    callback(\n                      'CHANNEL_ERROR',\n                      new Error(\n                        'mismatch between server and client bindings for postgres changes'\n                      )\n                    )\n                  return\n                }\n              }\n\n              this.bindings.postgres_changes = newPostgresBindings\n\n              callback && callback('SUBSCRIBED')\n              return\n            }\n          }\n        )\n        .receive('error', (error: { [key: string]: any }) => {\n          callback &&\n            callback(\n              'CHANNEL_ERROR',\n              new Error(\n                JSON.stringify(Object.values(error).join(', ') || 'error')\n              )\n            )\n          return\n        })\n        .receive('timeout', () => {\n          callback && callback('TIMED_OUT')\n          return\n        })\n    }\n\n    return this\n  }\n\n  presenceState<\n    T extends { [key: string]: any } = {}\n  >(): RealtimePresenceState<T> {\n    return this.presence.state as RealtimePresenceState<T>\n  }\n\n  async track(\n    payload: { [key: string]: any },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'track',\n        payload,\n      },\n      opts.timeout || this.timeout\n    )\n  }\n\n  async untrack(\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'untrack',\n      },\n      opts\n    )\n  }\n\n  /**\n   * Creates an event handler that listens to changes.\n   */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.SYNC}` },\n    callback: () => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}` },\n    callback: (payload: RealtimePresenceJoinPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}` },\n    callback: (payload: RealtimePresenceLeavePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL}`>,\n    callback: (payload: RealtimePostgresChangesPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`>,\n    callback: (payload: RealtimePostgresInsertPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`>,\n    callback: (payload: RealtimePostgresUpdatePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`>,\n    callback: (payload: RealtimePostgresDeletePayload<T>) => void\n  ): RealtimeChannel\n  /**\n   * The following is placed here to display on supabase.com/docs/reference/javascript/subscribe.\n   * @param type One of \"broadcast\", \"presence\", or \"postgres_changes\".\n   * @param filter Custom object specific to the Realtime feature detailing which payloads to receive.\n   * @param callback Function to be invoked when event handler is triggered.\n   */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\n    filter: { event: string },\n    callback: (payload: {\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\n      event: string\n      [key: string]: any\n    }) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\n    filter: { event: string },\n    callback: (payload: {\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\n      event: string\n      payload: T\n    }) => void\n  ): RealtimeChannel\n  on(\n    type: `${REALTIME_LISTEN_TYPES}`,\n    filter: { event: string; [key: string]: string },\n    callback: (payload: any) => void\n  ): RealtimeChannel {\n    return this._on(type, filter, callback)\n  }\n  /**\n   * Sends a message into the channel.\n   *\n   * @param args Arguments to send to channel\n   * @param args.type The type of event to send\n   * @param args.event The name of the event being sent\n   * @param args.payload Payload to be sent\n   * @param opts Options to be used during the send process\n   */\n  async send(\n    args: {\n      type: 'broadcast' | 'presence' | 'postgres_changes'\n      event: string\n      payload?: any\n      [key: string]: any\n    },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    if (!this._canPush() && args.type === 'broadcast') {\n      const { event, payload: endpoint_payload } = args\n      const options = {\n        method: 'POST',\n        headers: {\n          apikey: this.socket.apiKey ?? '',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages: [\n            { topic: this.subTopic, event, payload: endpoint_payload },\n          ],\n        }),\n      }\n\n      try {\n        const response = await this._fetchWithTimeout(\n          this.broadcastEndpointURL,\n          options,\n          opts.timeout ?? this.timeout\n        )\n\n        if (response.ok) {\n          return 'ok'\n        } else {\n          return 'error'\n        }\n      } catch (error: any) {\n        if (error.name === 'AbortError') {\n          return 'timed out'\n        } else {\n          return 'error'\n        }\n      }\n    } else {\n      return new Promise((resolve) => {\n        const push = this._push(args.type, args, opts.timeout || this.timeout)\n\n        if (args.type === 'broadcast' && !this.params?.config?.broadcast?.ack) {\n          resolve('ok')\n        }\n\n        push.receive('ok', () => resolve('ok'))\n        push.receive('timeout', () => resolve('timed out'))\n      })\n    }\n  }\n\n  updateJoinPayload(payload: { [key: string]: any }): void {\n    this.joinPush.updatePayload(payload)\n  }\n\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout): Promise<'ok' | 'timed out' | 'error'> {\n    this.state = CHANNEL_STATES.leaving\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`)\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef())\n    }\n\n    this.rejoinTimer.reset()\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy()\n\n    return new Promise((resolve) => {\n      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n\n      leavePush\n        .receive('ok', () => {\n          onClose()\n          resolve('ok')\n        })\n        .receive('timeout', () => {\n          onClose()\n          resolve('timed out')\n        })\n        .receive('error', () => {\n          resolve('error')\n        })\n\n      leavePush.send()\n\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {})\n      }\n    })\n  }\n\n  /** @internal */\n  _broadcastEndpointURL(): string {\n    let url = this.socket.endPoint\n    url = url.replace(/^ws/i, 'http')\n    url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '')\n    return url.replace(/\\/+$/, '') + '/api/broadcast'\n  }\n\n  async _fetchWithTimeout(\n    url: string,\n    options: { [key: string]: any },\n    timeout: number\n  ) {\n    const controller = new AbortController()\n    const id = setTimeout(() => controller.abort(), timeout)\n\n    const response = await this.socket.fetch(url, {\n      ...options,\n      signal: controller.signal,\n    })\n\n    clearTimeout(id)\n\n    return response\n  }\n\n  /** @internal */\n  _push(\n    event: string,\n    payload: { [key: string]: any },\n    timeout = this.timeout\n  ) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if (this._canPush()) {\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   *\n   * @internal\n   */\n  _onMessage(_event: string, payload: any, _ref?: string) {\n    return payload\n  }\n\n  /** @internal */\n  _isMember(topic: string): boolean {\n    return this.topic === topic\n  }\n\n  /** @internal */\n  _joinRef(): string {\n    return this.joinPush.ref\n  }\n\n  /** @internal */\n  _trigger(type: string, payload?: any, ref?: string) {\n    const typeLower = type.toLocaleLowerCase()\n    const { close, error, leave, join } = CHANNEL_EVENTS\n    const events: string[] = [close, error, leave, join]\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref)\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\n    }\n\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      this.bindings.postgres_changes\n        ?.filter((bind) => {\n          return (\n            bind.filter?.event === '*' ||\n            bind.filter?.event?.toLocaleLowerCase() === typeLower\n          )\n        })\n        .map((bind) => bind.callback(handledPayload, ref))\n    } else {\n      this.bindings[typeLower]\n        ?.filter((bind) => {\n          if (\n            ['broadcast', 'presence', 'postgres_changes'].includes(typeLower)\n          ) {\n            if ('id' in bind) {\n              const bindId = bind.id\n              const bindEvent = bind.filter?.event\n              return (\n                bindId &&\n                payload.ids?.includes(bindId) &&\n                (bindEvent === '*' ||\n                  bindEvent?.toLocaleLowerCase() ===\n                    payload.data?.type.toLocaleLowerCase())\n              )\n            } else {\n              const bindEvent = bind?.filter?.event?.toLocaleLowerCase()\n              return (\n                bindEvent === '*' ||\n                bindEvent === payload?.event?.toLocaleLowerCase()\n              )\n            }\n          } else {\n            return bind.type.toLocaleLowerCase() === typeLower\n          }\n        })\n        .map((bind) => {\n          if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n            const postgresChanges = handledPayload.data\n            const { schema, table, commit_timestamp, type, errors } =\n              postgresChanges\n            const enrichedPayload = {\n              schema: schema,\n              table: table,\n              commit_timestamp: commit_timestamp,\n              eventType: type,\n              new: {},\n              old: {},\n              errors: errors,\n            }\n            handledPayload = {\n              ...enrichedPayload,\n              ...this._getPayloadRecords(postgresChanges),\n            }\n          }\n          bind.callback(handledPayload, ref)\n        })\n    }\n  }\n\n  /** @internal */\n  _isClosed(): boolean {\n    return this.state === CHANNEL_STATES.closed\n  }\n\n  /** @internal */\n  _isJoined(): boolean {\n    return this.state === CHANNEL_STATES.joined\n  }\n\n  /** @internal */\n  _isJoining(): boolean {\n    return this.state === CHANNEL_STATES.joining\n  }\n\n  /** @internal */\n  _isLeaving(): boolean {\n    return this.state === CHANNEL_STATES.leaving\n  }\n\n  /** @internal */\n  _replyEventName(ref: string): string {\n    return `chan_reply_${ref}`\n  }\n\n  /** @internal */\n  _on(type: string, filter: { [key: string]: any }, callback: Function) {\n    const typeLower = type.toLocaleLowerCase()\n\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback,\n    }\n\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding)\n    } else {\n      this.bindings[typeLower] = [binding]\n    }\n\n    return this\n  }\n\n  /** @internal */\n  _off(type: string, filter: { [key: string]: any }) {\n    const typeLower = type.toLocaleLowerCase()\n\n    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n      return !(\n        bind.type?.toLocaleLowerCase() === typeLower &&\n        RealtimeChannel.isEqual(bind.filter, filter)\n      )\n    })\n    return this\n  }\n\n  /** @internal */\n  private static isEqual(\n    obj1: { [key: string]: string },\n    obj2: { [key: string]: string }\n  ) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false\n    }\n\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /** @internal */\n  private _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout()\n    if (this.socket.isConnected()) {\n      this._rejoin()\n    }\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   *\n   * @internal\n   */\n  private _onClose(callback: Function) {\n    this._on(CHANNEL_EVENTS.close, {}, callback)\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   *\n   * @internal\n   */\n  private _onError(callback: Function) {\n    this._on(CHANNEL_EVENTS.error, {}, (reason: string) => callback(reason))\n  }\n\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   *\n   * @internal\n   */\n  private _canPush(): boolean {\n    return this.socket.isConnected() && this._isJoined()\n  }\n\n  /** @internal */\n  private _rejoin(timeout = this.timeout): void {\n    if (this._isLeaving()) {\n      return\n    }\n    this.socket._leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  /** @internal */\n  private _getPayloadRecords(payload: any) {\n    const records = {\n      new: {},\n      old: {},\n    }\n\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(\n        payload.columns,\n        payload.record\n      )\n    }\n\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(\n        payload.columns,\n        payload.old_record\n      )\n    }\n\n    return records\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}